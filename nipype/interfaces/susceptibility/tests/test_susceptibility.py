# Unit test for the susceptibility tools, requires FSL to run BET
from nipype.testing import assert_equal
from nipype.interfaces.susceptibility import GenFm, PhaseUnwrap, PmScale
import nipype.interfaces.fsl as fsl
import argparse

parser = argparse.ArgumentParser(description='Susceptibility tools interface unit test')
parser.add_argument('-p','--phase', help='Phase image', required=True)
parser.add_argument('-i', '--mag', help='Magnitude image', required=True)
parser.add_argument('-m', '--mask', help='Mask image', required=False)
parser.add_argument('-etd', '--etd', help='Echo time difference (ms)', required=True,type=float)
parser.add_argument('-ped', '--ped', help='Phase encode direction (ms)', required=True)
parser.add_argument('-rot', '--rot', help='Read out time', required=True, type=float)
args = parser.parse_args()

# Begin by scaling the phase image
pm_scale = PmScale()
pm_scale.inputs.in_pm = args.phase
# Should rename the output of the scaled phase map
pm_scale.inputs.out_pm = pm_scale._gen_fname(args.phase, cwd=None, suffix='_scaled', change_ext=True)
print (pm_scale.inputs.out_pm)
result = pm_scale.run()

# Need to split the magnitude image

mask_fname = args.mask
# If no mask image was provided, then we need to run BET to make one
if args.mask is None:
    #BET your heart out
    bet = fsl.BET()
    bet.inputs.in_file = args.mag
    bet.inputs.mask = True
    bet.inputs.no_output = True
    mask_fname = bet._gen_fname(args.mag, cwd=None, suffix='_brain_mask', change_ext=True)
    bet.run()
    bet.inputs.out_file = bet._gen_fname(args.mag, cwd=None, change_ext=True)
    #bet.outputs.out_file =
    #bet.run()

# Then unwrapping
pm_unwrap = PhaseUnwrap()
pm_unwrap.inputs.in_fm = pm_scale.inputs.out_pm
pm_unwrap.inputs.in_mask = mask_fname
pm_unwrap.inputs.in_mag = args.mag
pm_unwrap.inputs.out_fm = pm_unwrap._gen_fname("unwrapped_fieldmap", cwd=None, change_ext=True)
pm_unwrap.run()

# Finally, estimate the field map and the corresponding deformation field
gen_fm = GenFm()
gen_fm.inputs.in_ufm = pm_unwrap.inputs.out_fm
gen_fm.inputs.in_mask = mask_fname
gen_fm.inputs.in_etd = args.etd
gen_fm.inputs.in_rot = args.rot
gen_fm.inputs.in_ped = args.ped
gen_fm.inputs.out_field = gen_fm._gen_fname(args.mag, cwd=None, suffix='_field', change_ext=True)
gen_fm.inputs.out_fm = gen_fm._gen_fname(args.mag, cwd=None, suffix='_final_fm', change_ext=True)
gen_fm.run()

print("fieldmaps should have been generated by now")
#gen_fm.inputs.


